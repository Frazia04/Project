package de.rptu.cs.exclaim.db;

import de.rptu.cs.exclaim.db.callback.AbstractStartupCallback;
import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import org.flywaydb.core.api.callback.Context;
import org.jooq.DSLContext;
import org.jooq.Field;
import org.jooq.Record;
import org.jooq.Table;
import org.jooq.impl.DSL;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Apply some changes to the Flyway schema history table before Flyway is run:
 * <ul>
 * <li>Flyway changed its default name for the schema history table in version 5.0.0, we may need to rename that table.
 *     See <a href="https://github.com/flyway/flyway/issues/1848">Flyway issue</a>.
 * <li>Sometimes we have to make some changes in existing migrations:
 *     <ul>
 *     <li>A database update changes the SQL parser and existing migrations no longer work with the current database
 *         version (we had this in migration version 22).
 *     <li>We want to support additional database systems (e.g. the PostgreSQL support was introduced later) and
 *         therefore need to do some changes in old migrations.
 *     </ul>
 *     In these cases, we need to update the checksum such that Flyway's validation does not fail. Furthermore, if the
 *     change that we made to our old migration also changes the semantics, we need to make sure that this change is
 *     also reflected in all existing databases. This class can apply a <code>fixer</code> action when an old checksum
 *     is updated to a new one.
 * </ul>
 * <p>
 * This class is used by {@link AbstractStartupCallback}.
 */
@Slf4j
@RequiredArgsConstructor
public class FixOldMigrations {
    /**
     * Old default Flyway table name (table will be renamed to the currently configured name)
     */
    private static final String OLD_FLYWAY_TABLE_NAME = "schema_version";

    @Value
    private static class MigrationFix {
        String version;
        int oldChecksum;
        int newChecksum;

        /**
         * Action to run when updating the checksum.
         * Use case: The old migration does no longer work in all database systems that we want to support. It has been
         * updated such that we can migrate fresh databases. A fix is needed to update existing databases that have been
         * migrated using the old version of this migration to the database schema that the new migration creates.
         */
        @Nullable Runnable fixer;

        /**
         * Short explanation why this change is required, for documentation here in this file and for logging.
         */
        String reason;
    }

    private final MigrationFix[] fixes = {
        // Many of the fixes are for PostgreSQL compatibility. I chose to adapt the existing migrations instead of
        // moving them to src/h2 and creating new ones in src/postgresql, because these fixes here can be deleted
        // once all existing deployments have been updated. This way, we benefit in the long-term by not maintaining
        // separate SQL scripts for H2 and PostgreSQL forever.
        new MigrationFix("10", 1868736434, -335003978, this::fixV10, "PostgreSQL support: DATETIME -> TIMESTAMP"),
        new MigrationFix("11", 1636289893, 125047450, this::fixV11, "PostgreSQL support: DATETIME -> TIMESTAMP"),
        new MigrationFix("12", -1245352420, -1579075153, this::fixV12, "PostgreSQL support: DATETIME -> TIMESTAMP, create new table instead of add column AFTER"),
        new MigrationFix("14", -1823311509, -94849749, null, "PostgreSQL support: Use DATE_TRUNC instead of DATEADD / DATEDIFF"),
        new MigrationFix("15", 890716735, 1134711486, null, "PostgreSQL support: create new table instead of add column AFTER"),
        new MigrationFix("16", 1282425386, 1788457773, null, "PostgreSQL support: avoid AFTER when adding column (already last column)"),
        new MigrationFix("17", 735295646, 637768796, this::fixV17, "PostgreSQL support: create new table instead of adding column FIRST, AUTO_INCREMENT -> GENERATED BY DEFAULT AS IDENTITY, avoid FORMATDATETIME, add missing primary key"),
        new MigrationFix("20", -1074056452, 1085868332, null, "PostgreSQL support: avoid AFTER when adding column (already last column)"),
        new MigrationFix("21", 325309565, 793856548, this::fixV21, "PostgreSQL support: DATETIME -> TIMESTAMP"),
        new MigrationFix("22", -168976389, -924803179, null, "syntax fix, see commit b378e8ed758fcf329aa78d9dae6f091da49fd766"),
        new MigrationFix("22", -924803179, 1143217192, null, "PostgreSQL support: AUTO_INCREMENT -> GENERATED BY DEFAULT AS IDENTITY"),
        new MigrationFix("23", -1576301535, -1994625392, this::fixV23, "H2 2.0.202 breaking change: column name day needs to be in quotes; PostgreSQL support: avoid AFTER when adding column (already last column)"),
    };

    private final Context context;
    private final DSLContext ctx;

    public void fixOldMigrations() {
        String flywayTable = context.getConfiguration().getTable();

        // Check if Flyway schema history table exists (old default name / currently configured name / none)
        log.debug("Checking for existing Flyway schema history table");
        String sql = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = ? AND TABLE_NAME ";
        List<Object> args = new ArrayList<>(3);
        args.add(Utils.getSchema(context));
        if (flywayTable.equals(OLD_FLYWAY_TABLE_NAME)) {
            sql += "= ?";
            args.add(flywayTable);
        } else {
            sql += "IN (?, ?)";
            args.add(flywayTable);
            args.add(OLD_FLYWAY_TABLE_NAME);
        }
        Set<String> existingTables = ctx.resultQuery(sql, args.toArray()).fetchSet(0, String.class);

        if (existingTables.isEmpty()) {
            log.debug("Flyway schema history table does not exist.");
            // No renaming or fixing necessary (fresh database).
        } else {
            if (existingTables.contains(flywayTable)) {
                log.debug("Flyway schema history table exists with correct name: {}", flywayTable);
            } else {
                log.info("Renaming old Flyway schema history table {} to {}", OLD_FLYWAY_TABLE_NAME, flywayTable);
                ctx.alterTable(DSL.quotedName(OLD_FLYWAY_TABLE_NAME)).renameTo(DSL.quotedName(flywayTable)).execute();
            }

            log.debug("Fetching previously executed migrations and their checksums");
            @AllArgsConstructor
            class MigrationStatus {
                private final int installed_rank;
                private Integer checksum;
            }
            Table<Record> table = DSL.table(DSL.quotedName(flywayTable));
            Field<Integer> installed_rank = DSL.field(DSL.quotedName("installed_rank"), Integer.class);
            Field<String> version = DSL.field(DSL.quotedName("version"), String.class);
            Field<Integer> checksum = DSL.field(DSL.quotedName("checksum"), Integer.class);
            Field<Boolean> success = DSL.field(DSL.quotedName("success"), Boolean.class);
            Map<String, MigrationStatus> migrations = ctx
                .select(installed_rank, version, checksum)
                .from(table)
                .where(version.in(Arrays.stream(fixes).map(MigrationFix::getVersion).toList()))
                .and(success)
                .forUpdate()
                .fetchMap(version, r -> new MigrationStatus(r.get(installed_rank), r.get(checksum)));

            // Apply migration fixes (in the order of our fixes array)
            for (MigrationFix fix : fixes) {
                MigrationStatus status = migrations.get(fix.version);
                if (status == null) {
                    log.debug("Migration {} not installed, no need to apply {}", fix.version, fix);
                } else if (status.checksum == null) {
                    log.debug("Migration {} installed rank {} has no checksum, not applying {}", fix.version, status.installed_rank, fix);
                } else if (status.checksum == fix.oldChecksum) {
                    log.info("Migration {} installed rank {} needs fixing: {}", fix.version, status.installed_rank, fix);
                    if (fix.fixer != null) {
                        fix.fixer.run();
                    }
                    ctx
                        .update(table)
                        .set(checksum, fix.newChecksum)
                        .where(installed_rank.eq(status.installed_rank))
                        .execute();
                    status.checksum = fix.newChecksum;
                } else {
                    log.debug("Migration {} installed rank {} has checksum {}, not applying {}", fix.version, status.installed_rank, status.checksum, fix);
                }
            }
        }
    }

    private void fixV10() {
        // DATETIME -> TIMESTAMP
        ctx.execute("ALTER TABLE testresult ALTER COLUMN time_request SET DATA TYPE TIMESTAMP");
        ctx.execute("ALTER TABLE testresult ALTER COLUMN time_started SET DATA TYPE TIMESTAMP");
        ctx.execute("ALTER TABLE testresult ALTER COLUMN time_done    SET DATA TYPE TIMESTAMP");
    }

    private void fixV11() {
        // DATETIME -> TIMESTAMP
        ctx.execute("ALTER TABLE uploads ALTER COLUMN upload_date SET DATA TYPE TIMESTAMP");
        ctx.execute("ALTER TABLE uploads ALTER COLUMN delete_date SET DATA TYPE TIMESTAMP");
    }

    private void fixV12() {
        // DATETIME -> TIMESTAMP
        ctx.execute("ALTER TABLE testresult ALTER COLUMN snapshot SET DATA TYPE TIMESTAMP");
    }

    private void fixV17() {
        // Primary key was missing in original migration, but it might already have been added externally
        // because H2 >= 2.0.202 requires it (it is referenced by a foreign key constraint).
        boolean keyIsMissing = ctx.meta().getTables().stream()
            .filter(t -> t.getName().equalsIgnoreCase("uploads"))
            .findFirst()
            .map(Table::getPrimaryKey)
            .isEmpty();
        if (keyIsMissing) {
            ctx.execute("ALTER TABLE uploads ADD PRIMARY KEY (id)");
        }
    }

    private void fixV21() {
        // DATETIME -> TIMESTAMP
        ctx.execute("ALTER TABLE exams ALTER COLUMN date SET DATA TYPE TIMESTAMP");
    }

    private void fixV23() {
        // H2: day (which used to be "DAY") -> "day"
        ctx.execute("ALTER TABLE groups ALTER COLUMN \"DAY\" RENAME TO \"day\"");
    }
}
